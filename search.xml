<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树（1）]]></title>
    <url>%2Fblog%2F2019%2F04%2F16%2F%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉树种类 满二叉树 一棵深度为k，且有个节点的二叉树 完全二叉树 除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点 二叉搜索树（BST） 指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 搜索、插入、删除的复杂度等于树高，期望，最坏 （数列有序，树退化成线性表）。 平衡树 类型：AVL树，红黑树，伸展树等等 其他：跳表，支持平衡树大多数操作的数据结构 二叉堆 二叉堆（英语：binary heap）是一种特殊的堆)，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆（最大二叉堆，最小二叉堆）。 ​]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解 JS 对象]]></title>
    <url>%2Fblog%2F2019%2F03%2F01%2Fjs%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[​ Js 的数据类型分为两种，一种是基本类型：Undefined, Null, Boolean, Number, String, Symbol。另一种则是引用类型：Object。 ​ 对象有很多种类，函数也是对象，对象都会有一个 __proto__ 属性获得对象的原型对象（在ES6标准中有提及，浏览器必须实现，其他环境不要求，不建议直接使用），还会有一个constructor 属性指向对象的构造函数。函数在创建的时候一般都会有prototype 属性（使用 bind 创建的函数无, 箭头函数也无）对于这几个属性，举几个例子： 12345678910111213141516// 实际使用推荐使用Object.getPrototypeOf()来获得原型对象.// 使用Object.create()或Object.setPrototypeOf()来设置原型对象Object.__proto__ === Function.prototype // true// 注意 Symbol 为构造函数Symbol.__proto__ === Function.prototype // trueFunction.prototype.constructor === Function // trueObject.prototype.__proto__ === null // truefunction Person(name) &#123; this.name = name&#125;let llg = new Person('llg')llg.constructor === Person // truellg.__proto__ === Person.prototype //truePerson.__proto__ === Function.prototype // true 从以上几个例子，我们可以知道函数 prototype 是用来确定实例对象 __proto__ 属性指向的，在构造函数生成实例对象的过程中需要用到 new 操作符，new 操作符其实是一个语法糖。实际实现代码 12345678function _new (constructor, ...params) &#123; // 以下两行可以简化为 const object = Object.create(constructor.prototype) const object = &#123;&#125; object.__proto__ = constructor.prototype const reObject = constructor.apply(object, params) return (typeof reObject === 'object' &amp;&amp; reObject !== null) ? reObject : object&#125; 原型对象，简单的说就是用来共享属性方法的，我们可以借助原型来实现继承。首先是原型式继承，在 ES5 中实现为 Object.create 方法 1234567891011121314function create(object, properties) &#123; function F()&#123;&#125; F.prototype = object const newObj = new F() if (typeof properties === 'object') &#123; Object.defineProperties(newObj, properties) &#125; return newObj&#125;const llg = create(&#123;sayName() &#123;console.log(this.name)&#125;&#125;, &#123;name: &#123;value: 'llg'&#125;&#125;)llg.sayName() // llg 就继承而言，一般通用的是寄生组合式继承，主要实现如下： 1234567891011121314151617181920212223242526272829function inherit(subType, superType) &#123; let prototype = Object.create(superType.prototype) prototype.constructor = subType subType.prototype = prototype Object.setPrototypeOf ? Object.setPrototypeOf(subType, superType) : subType.__proto__ === superType&#125;function Pet(name) &#123;this.name = name&#125;Pet.prototype.getName = function() &#123; console.log(this.name)&#125;function Dog(name, type) &#123; Pet.call(this, name) this.type = type&#125;inherit(Dog, Pet)Dog.prototype.getType = function() &#123; console.log(this.type)&#125;const xh = new Dog('XiaoHuang', 'husky')xh.getName() // XiaoHuangxh.getType() // huskyxh.hasOwnProperty('getName') // false 到了 ES6 有了 class 关键字后，继承之类的也就变得更加的直观了，定义构造函数简洁明了，而且可以将 getter, setter 与静态函数封装在一起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ES6class Person &#123; // 相当于构造函数 constructor(name, age) &#123; this.name = name this._age = age &#125; //定义在 Person 上的方法 static sayHello() &#123; console.log('Hello World') &#125; // 以下方法相当于定义 Peron.prototype 上的方法 get age() &#123; return this._age &#125; set age(age) &#123; this._age = age &#125; getName() &#123; return this.name &#125;&#125;class Chinese extends Person &#123; constructor(name, age, province) &#123; // 相当于 Person.call(this, name, age) super(name, age) this.province = province &#125; static sayHello() &#123; super.sayHello() &#125;&#125;const llg = new Chinese('llg', 21, 'WuHan')llg.getName()Chinese.sayHello()// 模块模式定义私有属性与静态属性(function(window) &#123; // 私有属性 const friends = [] window.Person = class &#123; constructor(name) &#123; this.name = name &#125; addFriends(...name) &#123; friends.push(...name) &#125; friendsCount() &#123; return friends.length &#125; &#125; window.Person.sayHello = function() &#123; console.log('Hello World!') &#125;&#125;)(window)Person.sayHello() // Hello World!const llg = new Person('llg')llg.addFriends('l', 'l', 'g')llg.friendsCount() // 3 在 ES6 的中使用 class 定义静态属性与私有属性的方法仍然与 ES5中一样 ，当然在之后的 ES 版本中将会给 class 加入私有属性与静态属性让 class 变得更为强大。ES6 的类声明虽然是 ES5 的构造函数形式的一个语法糖，但是它们之间存在着很多的差异： 类声明默认在严格模式下，不能被提升 类声明中定义的所有方法都是不可枚举的，在 ES5 中需通过 Object.defineProperty() 指定不可枚举 类内部有名为[[construct]] 的内部方法，通过 new 调用不含 [[construct]] 的方法都会报错 类的构造函数只能通过 new 调用，否则报错 类内部不能修改类名 在 ES6 中继承使用关键字 extends , 静态成员也可以被继承，extends后面可以接任意的表达式，而且还可以继承内建对象。 123456789// 继承内建对象 ES5 无法完成，如下代码 Babel 转义后运行会出错class MyArr extends Array &#123; unique() &#123; return [...new Set(this)] &#125;&#125;const arr = new MyArr(1, 1, 3)arr.length // 3arr.unique() // [1, 3] 在 ES6 中可以使用 new.target 属性判断调用的构造函数的种类, 使用 new.target 可以实现抽象基类 12345678910111213141516class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('不能实例化') &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(width, length) &#123; // 必须有super， 且要出现在 this 前面 super() this.width = width this.length = length &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async and await（前言）]]></title>
    <url>%2Fblog%2F2018%2F06%2F30%2FAsync-and-await%2F</url>
    <content type="text"><![CDATA[Async 与 await 使用起来很是方便，然而其与 Promise, setTimeout联合使用时，要搞懂运行的顺序却不是那么的容易。先举两个例子。（注：resolve 并不是代表已经 fullfilled，理解这点很重要） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647console.log("start")function t1() &#123; console.log("t1 start") setTimeout(() =&gt; &#123; console.log("setTimeout in t1") &#125;, 0) return Promise.resolve("t1 end")&#125;function t2() &#123; console.log("t2 start") return Promise.resolve("t2 end")&#125;async function asy1() &#123; console.log("async start") const rt1 = await t1() console.log(rt1) const rt2 = await t2() console.log(rt2)&#125;asy1()const p1 = new Promise(resolve =&gt; &#123; console.log("p1 start") resolve("p1 then")&#125;)p1.then(val =&gt; &#123; console.log(val)&#125;)setTimeout(() =&gt; &#123; console.log("setTimeout") Promise.resolve("promise in setTimeout").then(val =&gt; &#123; console.log(val) &#125;)&#125;, 0)console.log("end") 运行结果如下图所示： 上面的代码可能一开始看上去就会看上去感觉很晕的样子，但这段代码也就只是涉及到了事件循环，宏任务队列与微任务队列的知识而已，我们要注意以下几点: ​ 1. await 到底有什么作用呢? 具体的大家可以去阅读 官方文档第二段， 简而言之，执行到 await 时会继续执行其后面的代码， 然后切换执行上下文，执行 async 函数后的代码。然后根据返回值，如果是promise的话，加入微任务队列等待fullfilled 或 rejected并取得返回值，否则继续执行后续代码 node 的运行结果与浏览器是不同的，故会有所出入]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎大家来看我的博客，也欢迎各位加我的 QQ 交流技术上的问题^_^ QQ: 985395976]]></content>
      <tags>
        <tag>hello-world</tag>
      </tags>
  </entry>
</search>
